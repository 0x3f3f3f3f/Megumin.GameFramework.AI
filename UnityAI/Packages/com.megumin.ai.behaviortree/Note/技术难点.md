# 技术难点
这里是海面下的冰山！  

这里记录一些在插件设计之前，没有意识到的问题。  
在插件开发和使用到一定程度后，问题才随之出现，解决这些问题耗费了大量的时间。  
如果一开始就意识到这些问题，可能设计之初就会有更好的架构，也可能直接放弃开发。  

## 序列化反序列化

Q: 代码更改后，类名变更，命名空间变更，旧的序列化文件无法正确反序列的问题。  
A: 建立全局查找表。  
- 增加别名特性，反序列开始前反射处理全部别名。  
  当类型找不到时,从别名映射中查找。
- 类名替换机制，当找不到类型时，尝试替换一部分类名，替换命名空间等。  


Q：没有正确反序列化的节点，如果忽略，作为Selector的子节点应该返回失败，
作为Sequence的子节点应该返回成功。  
A: 在节点调用过程中增加from函数，节点知道他的运行时是通过哪个节点进入的。
不能查找自己的父节点，可能存在菱形链接，含有多个父节点。只能运行时传入。  
当节点Enabled == false，会调用此函数的GetIgnoreResult，动态返回结果。  
注意：当反序列化失败时，节点会被missnode替代，调用missnode的GetIgnoreResult函数，而不是当前节点的函数。

```cs
/// <summary>
/// 根据调用节点返回不同的结果值，使调用节点忽略当前节点。
/// <para/> 父节点是Selctor 返回Failed，可以允许Selctor 跳过当前节点继续执行下个节点而是直接失败。
/// </summary>
/// <param name="from"></param>
/// <returns></returns>
protected virtual Status GetIgnoreResult(BTNode from)
{
    if (from is Selector)
    {
        return Status.Failed;
    }
    else
    {
        return Status.Succeeded;
    }
}
```
